// src/lib/database-retry.ts
import { prisma } from './prisma';

interface RetryOptions {
  maxRetries?: number;
  delayMs?: number;
  backoffMultiplier?: number;
}

/**
 * –í—ã–ø–æ–ª–Ω–∏—Ç—å –æ–ø–µ—Ä–∞—Ü–∏—é —Å –±–∞–∑–æ–π –¥–∞–Ω–Ω—ã—Ö —Å –ø–æ–≤—Ç–æ—Ä–Ω—ã–º–∏ –ø–æ–ø—ã—Ç–∫–∞–º–∏
 */
export async function withDatabaseRetry<T>(
  operation: () => Promise<T>,
  options: RetryOptions = {}
): Promise<T> {
  const {
    maxRetries = 3,
    delayMs = 1000,
    backoffMultiplier = 1.5
  } = options;

  let lastError: Error | null = null;
  let currentDelay = delayMs;

  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      // –ü–æ–ø—ã—Ç–∫–∞ –≤—ã–ø–æ–ª–Ω–∏—Ç—å –æ–ø–µ—Ä–∞—Ü–∏—é
      return await operation();
    } catch (error) {
      lastError = error as Error;
      
      // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —Å—Ç–æ–∏—Ç –ª–∏ –ø–æ–≤—Ç–æ—Ä—è—Ç—å
      const shouldRetry = isRetryableError(lastError) && attempt < maxRetries;
      
      if (!shouldRetry) {
        throw lastError;
      }
      
      console.warn(`üîÑ Database operation failed (attempt ${attempt}/${maxRetries}), retrying in ${currentDelay}ms:`, lastError.message);
      
      // –ñ–¥–µ–º –ø–µ—Ä–µ–¥ —Å–ª–µ–¥—É—é—â–µ–π –ø–æ–ø—ã—Ç–∫–æ–π
      await delay(currentDelay);
      currentDelay *= backoffMultiplier;
    }
  }
  
  throw lastError;
}

/**
 * –ü—Ä–æ–≤–µ—Ä–∏—Ç—å, –º–æ–∂–Ω–æ –ª–∏ –ø–æ–≤—Ç–æ—Ä–∏—Ç—å –æ–ø–µ—Ä–∞—Ü–∏—é –ø—Ä–∏ –¥–∞–Ω–Ω–æ–π –æ—à–∏–±–∫–µ
 */
function isRetryableError(error: Error): boolean {
  const errorMessage = error.message.toLowerCase();
  
  // –û—à–∏–±–∫–∏ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ –ë–î, –∫–æ—Ç–æ—Ä—ã–µ –º–æ–∂–Ω–æ –ø–æ–≤—Ç–æ—Ä–∏—Ç—å
  const retryableErrors = [
    'max client connections reached',
    'connection terminated',
    'connection reset',
    'timeout',
    'connection refused',
    'network error',
    'econnreset',
    'econnrefused',
    'etimedout',
    'database unavailable'
  ];
  
  return retryableErrors.some(retryableError => 
    errorMessage.includes(retryableError)
  );
}

/**
 * –ó–∞–¥–µ—Ä–∂–∫–∞ –≤ –º–∏–ª–ª–∏—Å–µ–∫—É–Ω–¥–∞—Ö
 */
function delay(ms: number): Promise<void> {
  return new Promise(resolve => setTimeout(resolve, ms));
}

/**
 * –ë–µ–∑–æ–ø–∞—Å–Ω–æ–µ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–µ –æ–ø–µ—Ä–∞—Ü–∏–∏ —Å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º
 */
export async function safeUserOperation<T>(
  telegramId: string,
  operation: (user: any) => Promise<T>
): Promise<T> {
  return withDatabaseRetry(async () => {
    // –ù–∞–π—Ç–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
    const user = await prisma.user.findUnique({
      where: { telegramId },
      select: {
        id: true,
        telegramId: true,
        firstName: true,
        lastName: true,
        username: true,
        avatar: true,
        role: true,
        isPremium: true
      }
    });
    
    if (!user) {
      throw new Error('–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–µ –Ω–∞–π–¥–µ–Ω');
    }
    
    return await operation(user);
  }, {
    maxRetries: 3,
    delayMs: 500,
    backoffMultiplier: 2
  });
}

/**
 * –°–æ–∑–¥–∞—Ç—å —Å–æ–µ–¥–∏–Ω–µ–Ω–∏–µ —Å –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–µ–º –≤—Ä–µ–º–µ–Ω–∏
 */
export async function withTimeout<T>(
  operation: () => Promise<T>,
  timeoutMs: number = 10000
): Promise<T> {
  return Promise.race([
    operation(),
    new Promise<never>((_, reject) => {
      setTimeout(() => {
        reject(new Error(`Operation timed out after ${timeoutMs}ms`));
      }, timeoutMs);
    })
  ]);
}